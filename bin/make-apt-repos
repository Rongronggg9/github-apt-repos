#!/usr/bin/python3
"""
Make apt repositories from *.deb's separated by architecture and component.
"""

import sys
import os
import re
import subprocess
import shutil
import logging
import argparse

logger = logging.getLogger(os.path.splitext(os.path.basename(__file__))[0])

DEB_BASENAME_RE = r'{package}([-_\.](?P<dist>.+)|)_{version}_{arch}'

parser = argparse.ArgumentParser(description=__doc__)
parser.add_argument(
    'user-id', help='The GPG user ID of the key to use for signing')
parser.add_argument(
    'pub-key', help='The path to the exported GPG public key')


def collect_dists_archs(dir=os.curdir):
    """
    Group packages by dist and architecture.

    Assumes the following package filename format:
    
    'package-dist_version_arch.deb' 
    """
    dists = {}
    # TODO Use subprocess.Popen to stream results for large collections
    for deb in subprocess.run(
            ['find', '.', '-iname', '*.deb'],
            check=True, stdout=subprocess.PIPE,
            encoding=sys.stdout.encoding
    ).stdout.strip().split('\n'):
        arch = subprocess.run(
            ['dpkg-deb', '-f', deb, 'Architecture'], check=True,
            stdout=subprocess.PIPE, encoding=sys.stdout.encoding
        ).stdout.strip()
        package = subprocess.run(
            ['dpkg-deb', '-f', deb, 'Package'], check=True,
            stdout=subprocess.PIPE, encoding=sys.stdout.encoding
        ).stdout.strip()
        version = subprocess.run(
            ['dpkg-deb', '-f', deb, 'Version'], check=True,
            stdout=subprocess.PIPE, encoding=sys.stdout.encoding
        ).stdout.strip()
        deb_basename_match = re.match(
            DEB_BASENAME_RE.format(
                arch=arch, package=package, version=version),
            os.path.splitext(os.path.basename(deb))[0])
        dist = deb_basename_match.group(2)
        dists.setdefault(dist, {}).setdefault(arch, []).append(deb)
    return dists


def main(user_id, pub_key):
    """
    Make apt repositories from *.deb's separated by architecture and component.
    """
    dists = collect_dists_archs()
    for dist, archs in dists.items():
        path = 'apt'
        if dist is not None:
            path = os.path.join(path, dist)
        for arch, debs in archs.items():
            # Make a dist+arch specific directory
            arch_path = os.path.join(path, arch)
            os.makedirs(arch_path, exist_ok=True)

            # Add each deb for this dist+arch to Packages
            with open(os.path.join(arch_path, 'Packages'), 'w') as packages:
                for deb in debs:
                    logger.info('Writing %r', packages.name)
                    subprocess.run(
                        ['dpkg-scanpackages', '-m', deb, '/dev/null'],
                        check=True, stdout=packages)

            # Make and sign the Release files
            with open(os.path.join(arch_path, 'Release'), 'w') as release:
                logger.info('Writing %r', release.name)
                subprocess.run(
                    ['apt-ftparchive', 'release', arch_path],
                    check=True, stdout=release)
            in_release_path = os.path.join(arch_path, 'InRelease')
            logger.info('Writing %r', in_release_path)
            subprocess.run(
                ['gpg', '-u', user_id, '--clearsign',
                 '-o', in_release_path, release.name], check=True)
            release_gpg_path = os.path.join(arch_path, 'Release.gpg')
            logger.info('Writing %r', release_gpg_path)
            subprocess.run(
                ['gpg', '-u', user_id, '-abs',
                 '-o', release_gpg_path, release.name], check=True)

            # Copy the public key
            pub_key_path = os.path.join(arch_path, os.path.basename(pub_key))
            logger.info('Copying %r', pub_key_path)
            subprocess.run(['cp', pub_key, pub_key_path], check=True)

if __name__ == '__main__':
    logging.basicConfig(level=logging.INFO)
    args = parser.parse_args()
    main(getattr(args, 'user-id'), getattr(args, 'pub-key'))
